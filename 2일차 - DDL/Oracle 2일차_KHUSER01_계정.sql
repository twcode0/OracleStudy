CREATE TABLE USER_NO_CONSTRAINT(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);
DROP TABLE USER_NO_CONSTRAINT;
SELECT * FROM USER_NO_CONSTRAINT;

-- 1, khuser01, pass01, 일용자, 남, 01012341234, khuser01@naver.com
INSERT INTO USER_NO_CONSTRAINT
VALUES(1, 'khuser01', 'pass01', '일용자','남', '01012341234', 'khuser01@naver.com');
ROLLBACK;
COMMIT;

--제약조건 : 중복 최소화 null상태로 값이 입력된느것을 방지.
INSERT INTO USER_NO_CONSTRAINT 
VALUES(null, null, null,null,null,null,null);

CREATE TABLE USER_NOTNULL(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL,
    USER_PW VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    -- 옆에 붙이는걸 COLOUM LEVEL 방식
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

DROP TABLE USER_NOTNULL;
INSERT INTO UESR_NOTNULL
VALUES(1, 'khuser01', 'pass01', '일용자', null, null, null);

CREATE TABLE USER_UNIQUE(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) UNIQUE ,
    USER_PW VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

INSERT INTO USER_UNIQUE
VALUES(1, 'khuser01', 'pass01', '일용자', null, null, null);

INSERT INTO USER_UNIQUE
VALUES(1, null, 'pass01', '일용자', null, null, null);
--UNIQUE로 중복은 제거했지만 null이 들어가는 것을 막지못했다.

SELECT * FROM USER_UNIQUE;

CREATE TABLE USER_PRIMARY_KEY(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PW VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);
-- unique + not null = primary key
DROP TABLE USER_PRIMARY_KEY;

INSERT INTO USER_PRIMARY_KEY
VALUES(1,'khuser01', 'pass01', '이용자', null, null, null);
INSERT INTO USER_PRIMARY_KEY
VALUES(1,'khuser02', 'pass02', '이용자', null, null, null);
COMMIT;

CREATE TABLE USER_CHECK(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) primary key,
    USER_PW VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M', 'F', 'S')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

DROP TABLE USER_CHECK;

INSERT INTO USER_CHECK
VALUES(1,'khuser01', 'pass01', '일용자', 'S', null, null);
INSERT INTO USER_CHECK
VALUES(1,'khuser02', 'pass02', '이용자', '남자', null, null);
INSERT INTO USER_CHECK
VALUES(1,'khuser03', 'pass03', '삼용자', 'Male', null, null);


SELECT * FROM USER_CHECK;

CREATE TABLE USER_DEFAULT(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) primary key,
    USER_PW VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M', 'F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50),
    USER_DATE DATE DEFAULT SYSDATE
);
-- 데이터 입력을 간소화 할 수 있음

DROP TABLE USER_DEFAULT;

INSERT INTO USER_DEFAULT
VALUES (1, 'khuser01', 'pass01', '일용자', 'M', '01012341234', 'khuser01@naver.com', DEFAULT);

INSERT INTO USER_DEFAULT
VALUES (2, 'khuser03', 'pass02', '이용자', 'M', '01012341234', 'khuser01@naver.com',SYSDATE+7);

SELECT * FROM USER_DEFAULT;

CREATE TABLE USER_GRADE(
   GRADE_CODE NUMBER NOT NULL, 
   GRADE_NAME VARCHAR2(30)
);

SELECT * FROM USER_GRADE;

INSERT INTO USER_GRADE VALUES (10 , '일반회원');
INSERT INTO USER_GRADE VALUES (20 , '우수회원');
INSERT INTO USER_GRADE VALUES (30 , '특별회원');


CREATE TABLE USER_FOREIGN_KEY(
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PW VARCHAR2(30) UNIQUE NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M', 'F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50),
    USER_DATE DATE DEFAULT SYSDATE,
    GRADE_CODE NUMBER REFERENCES USER_GRADE(GRADE_CODE) ON DELETE CASCADE
);

DROP TABLE USER_FOREIGN_KEY;
SELECT * FROM USER_FORIGN_KEY;
INSERT INTO USER_FOREIGN_KEY
VALUES (1, 'khuser01', 'pass01', '일용자', 'M', null, null, DEFAULT, 10);
INSERT INTO USER_FOREIGN_KEY
VALUES (2, 'khuser02', 'pass02', '이용자', 'M', null, null, DEFAULT, 20);
INSERT INTO USER_FOREIGN_KEY
VALUES (3, 'khuser03', 'pass03', '삼용자', 'M', null, null, DEFAULT, 30);
INSERT INTO USER_FOREIGN_KEY
VALUES (4, 'khuser04', 'pass04', '사용자', 'M', null, null, DEFAULT, 40);

DELETE FROM USER_FOREIGN_KEY;

DELETE FROM USER_GRADE WHERE GRADE_CODE = 40;

-- 테이블명 : SHOP_MEMBER
-- 저장해야할 데이터 : 1, khuser01, pass01, 일용자, M, 01012341234, khuser01@naver.com

-- 테이블명 : SHOP_BUY
-- 저장해야할 데이터 : 1, khuser01, 농구화, 24/06/14

CREATE TABLE SHOP_MEMBER(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(30) UNIQUE NOT NULL,
    USER_PW VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN ('M', 'F')),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

SELECT * FROM SHOP_MEMBER;
COMMIT;
DROP TABLE SHOP_MEMBER;

INSERT INTO SHOP_MEMBER
VALUES(1, 'khuser01', 'pass01', '일용자', 'M', '01012341234','khuser01@naver.com');
INSERT INTO SHOP_MEMBER
VALUES(2, 'khuser02', 'pass02', '일용자', 'M', '01012341234','khuser01@naver.com');
SELECT * FROM SHOP_MEMBER;
DELETE FROM SHOP_MEMBER WHERE USER_ID = 'khuser01';

CREATE TABLE SHOP_BUY(
    BUY_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(30) REFERENCES SHOP_MEMBER(USER_ID) ON DELETE SET NULL,
    PRODUCT_NAME VARCHAR2(20),
    REG_DATA DATE DEFAULT SYSDATE
);
DROP TABLE SHOP_BUY;
-- SHOP_BUY의 USER_ID는 SHOP_MEMBER의 USER_ID가 가지고있는
-- khuser01, khuser02 등... 만 넣을 수 있어요
SELECT * FROM SHOP_BUY;
INSERT INTO SHOP_BUY
VALUES(1, 'khuer01', '농구화', DEFAULT);
INSERT INTO SHOP_BUY
VALUES(2, 'khuer02', '축구화', DEFAULT);


-- 외래키 FOREIGN KEY
-- 자식 테이블에서 부모 테이블이 가지고 있는 컬럼의 필드값으로만 INSERT하도록 하는 것
-- 참조 무결성을 보장하는 제약조건임.
-- 외래키 설정방법
-- 컬럼레벨 : REFERENCES 부모테이블(컬럼명) 삭제 옵션 (ON DELETE SET NULL, ON DELETE SET NULL)
-- 외래키 삭제옵션
-- 1. 기본옵션 ON DELETE RESTRICTED
-- 2. 연관된 모든 것 삭제 옵션 : ON DELETE CASCADE
-- 3. NULL로 만드는 삭제 옵션 : ON DELETE SET NULL
-- 부모테이블의 데이터 삭제 시도시 자식 테이블의 데이터를 처리하는 방법.
